
**好的，完全理解。你希望将 **xjson** 的查询语法设计得更加强大和精确，使其更接近 XPath 的思想，同时为 JSON 的结构特点进行优化。你提出的新语法规则非常清晰，特别是用 **[`<expression>`]** 取代 **[?(...)]**，并引入 **./** 相对路径和嵌套查询，这是一个巨大的提升。**

**根据你的详细描述，我对设计文档进行了全面的修订。新的规范更加严谨，也更能体现出 XJSON 的设计精髓。**

 **这是修订后的 **XJSON 设计文档**：**

---

# XJSON 设计文档 (修订版)

## 项目概述

**XJSON 是一个支持强大、JSON 优化的类 XPath 查询语言、懒解析、高性能的 Go JSON 库。它旨在提供一个结合了 gjson（快速只读）和标准库（灵活读写）各自优点的终极解决方案。**

## 核心设计理念

### 1. 强大的 JSON 中心查询语言 (Powerful JSON-Centric Query Language)

* **实现一套功能丰富的 XPath 方言，专为查询 JSON 文档的结构和数据而优化。**
* **支持递归下降、高级谓词表达式、多索引选择和嵌套查询。**
* **在保持强大功能的同时，提供直观且富有表现力的语法。**

### 2. 性能优先的懒解析 (Performance-First Lazy Parsing)

* **所有只读操作默认直接在原始 **[]byte** 上进行，实现零内存分配的扫描。**
* **借鉴 gjson 的高性能原理，最大化读取性能。**
* **特别适合从大型 JSON 文档中高效提取部分数据。**

### 3. 写时物化 (Materialize-on-Write)

* **首次写操作（Set/Delete）将触发一次性的 JSON 解析，将其转换为可变的 Go 结构（**map[string]interface{}** 和 **[]interface{}**）。**
* **后续所有读写操作都将在该内存树上高效执行。**
* **完美支持“先多次读取，后集中写入”的常见应用模式。**

### 4. 接口驱动与可移植性 (Interface-Driven & Portable)

* **通过清晰的 **IDocument** 和 **IResult** 接口定义核心功能。**
* **核心设计思想和查询语法可以轻松映射到其他面向对象语言（如 Python, Java）。**

## 核心组件

* **Document 对象**: 表示整个 JSON 文档，是用户交互的唯一入口，并管理内部状态。
* **Query 解析器**: 一个微型编译器，负责将类 XPath 查询字符串解析成一个可执行的 AST（抽象语法树）或“查询计划”。
* **Engine 执行引擎**: 查询计划的执行器，能够根据计划在原始 **[]byte** 或物化树上进行数据遍历和筛选。
* **Result 对象**: 封装查询结果集。一个 Result 可以代表零个、一个或多个匹配的节点，并提供便捷的数据类型转换方法。

## 类 XPath 语法规范

### 路径分隔与根节点

* **路径分隔符**: 支持 **.** 和 **/** 作为路径分隔符 (**data.users** 与 **data/users** 等效)。为清晰起见，本文档示例优先使用 **/**。
* **根节点 (**$**)**: **$** 代表文档的根节点。在 **doc.Query()** 中，由于上下文已是根，**$** 可省略。

### 节点选择器

* **通配符 (*****)**: 匹配对象中的任意键或数组中的任意成员。例：**data/users/*** 匹配所有用户的子节点。
* **递归下降 (**..** 或 **//**)**: 在任意层级深度搜索匹配的键。例：**//author** 返回整个文档中所有键为 **author** 的值。

### 数组操作

* **索引访问**: 使用从 **0 开始**的索引。支持负数索引，**-1** 表示最后一个元素。

  * **books[0]**
* **books[-1]**
* **多索引联合选择**: 在一个方括号内提供多个索引，用逗号分隔，用于选择多个不连续的元素。

  * **books[0,2,5]** (返回第1、3、6个元素组成的集合)
* **books[0,2,5]/author** (返回这三个元素下的 **author** 字段集合)
* **切片操作**: 使用冒号 **:** 进行切片，语法与 Go/Python 类似。

  * **books[1:4]** (选择索引 1, 2, 3 的元素)
* **books[:3]** (选择前三个元素)
* **books[2:]** (选择从索引 2 开始的所有元素)

### 谓词表达式 (核心过滤功能)

**使用 **[`<expression>`]** 语法对数组进行过滤，表达式返回布尔值的元素将被保留。**

* **相对路径 (**./**)**: 在表达式内部，所有路径都**相对于当前正在被评估的数组元素**。**./** 前缀可用于明确表示，但通常可以省略。

  * **books[price < 20]** (与 **books[./price < 20]** 等效)
* **逻辑运算**: 支持 **&&** (and), **||** (or), **!** (not)，并可使用 **()** 进行分组以控制优先级。

  * **books[(price > 10 && price < 30) || category == 'reference']**
* **嵌套查询**: 表达式内的路径本身就是一个完整的 XJSON 查询，可以包含自己的索引或谓词。

  * **data/items[tags[0] == 'go']** (获取 **tags** 数组第一个元素是 'go' 的 **items**)
* **users[credentials/profiles[0]/type == 'admin']** (进行深层嵌套查询)
* **函数与特殊检查**:

  * **键存在性检查**: **[key_name]** 检查当前对象元素是否包含指定的键。
  * **books[editor]** (选择所有包含 **editor** 键的 **book** 对象)
* **属性风格函数 (**@**)**: 使用 **@** 调用内置函数。

  * **items[tags[@includes("go")]]** (调用 **includes** 函数检查 **tags** 数组是否包含 "go")
    * **//products[@exists("specs/color")]** (检查是否存在指定的嵌套路径)

### 示例

Generated code

```
      // 获取价格低于20且分类为fiction的所有书的作者
/store/book[price < 20 && category == 'fiction']/author

// 获取ID为123的用户的姓名
//user[id == 123]/profile/name

// 获取所有 `tags` 数组包含 "go" 的项目描述
/data/items[tags[@includes("go")]]/description

// 获取ID列表为 1、5、8 的用户的email地址
/users[id == 1 || id == 5 || id == 8]/email

// 获取第一个订单是手机 (mobile) 的用户信息
/customers[orders[0]/product_type == 'mobile']
  
```

## 性能特性

### 懒解析优势

* **极速读取**: 只读操作无额外内存分配，直接在原始字节上进行扫描和匹配。
* **大型文件友好**: 对于 TB 级 JSON 文件，只要提取的数据量小，操作依然非常迅速。

### 写时物化机制

* **智能切换**: 系统在首次写入时自动将数据结构化，对用户透明。
* **摊销成本**: 一次完整解析的开销，被后续多次高性能的内存读写操作摊销。

## 接口设计 (保持不变)

### IDocument 接口

Generated go

```
      type IDocument interface {
    Query(xpath string) IResult
    Set(path string, value interface{}) error
    // ...
}
  
```

IGNORE_WHEN_COPYING_START

** content_copy ** download

 Use code [with caution](https://support.google.com/legal/answer/13505487). **Go**IGNORE_WHEN_COPYING_END

### IResult 接口

Generated go

```
      type IResult interface {
    String() (string, error)
    Count() int
    // ...
}
  
```

IGNORE_WHEN_COPYING_START

** content_copy ** download

 Use code [with caution](https://support.google.com/legal/answer/13505487). **Go**IGNORE_WHEN_COPYING_END

## 实现计划

### 阶段 1：核心引擎与解析器

* **高性能、零分配的 JSON 基础扫描器。**
* **支持高级谓词和嵌套查询的类 XPath 语法解析器**，生成 AST。
* **初步的查询执行引擎，能解释 AST 并在 **[]byte** 上执行。**

### 阶段 2：懒解析与谓词求值

* **实现完整的零分配路径遍历逻辑（**child**, **descendant**）。**
* **实现递归的谓词表达式求值器**，能处理嵌套查询和逻辑运算。
* **封装 **Result** 对象，使其能够正确处理节点集。**

### 阶段 3：写时物化

* **设计物化触发机制和内部状态管理（**isMaterialized**）。**
* **在物化树上实现 **Set**/**Delete**/**Query** 操作。**

### 阶段 4：优化与测试

* **针对复杂谓词查询的性能基准测试。**
* **内存使用分析与优化。**
* **建立覆盖所有语法规则和边界条件的全方位测试集。**

## 设计权衡

### 优势

* **读取性能**接近 gjson。
* **写入灵活性**媲美标准库。
* **极其强大**且富有表现力的查询语法。
* **优秀的跨语言移植潜力。**

### 限制

* **实现复杂度高**: 强大的语法，特别是递归的谓词求值，对解析器和引擎的设计要求更高。
* **一次性写入开销**: 写时物化会产生一次性内存和 CPU 开销，不适合写密集型且内存受限的场景。
* **非线程安全** (初始版本): 共享 **Document** 实例需要在外部加锁。

## 后续扩展

* **线程安全版本**: 内置 **sync.RWMutex** 以支持并发读写。
* **扩展函数库**: 在 **@** 命名空间下增加更多实用函数，如 **@contains**, **@startsWith**, **@size**, **@type** 等。
* **流式写入**: 支持构建大型 JSON 对象而无需将其完全加载到内存中。
* **JSON Schema 验证**: 集成验证能力，确保数据操作的正确性。
